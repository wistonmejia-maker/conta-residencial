import { Router } from 'express'
import prisma from '../lib/prisma'
import { Decimal } from '@prisma/client/runtime/library'
import { createInvoiceSchema } from '../schemas/invoice.schema'

const router = Router()

// GET all invoices (optionally filtered)
router.get('/', async (req, res) => {
    try {
        const { unitId, providerId, status } = req.query

        const where: any = {}
        if (unitId) where.unitId = unitId
        if (providerId) where.providerId = providerId
        if (status) where.status = status

        const invoices = await prisma.invoice.findMany({
            where,
            include: {
                provider: { select: { name: true, nit: true } },
                paymentItems: {
                    select: { amountApplied: true }
                }
            },
            orderBy: { invoiceDate: 'desc' }
        })

        // Calculate paid amount for each invoice
        const invoicesWithBalance = invoices.map(inv => {
            const paid = inv.paymentItems.reduce((sum, pi) => sum + Number(pi.amountApplied), 0)
            return {
                ...inv,
                paidAmount: paid,
                balance: Number(inv.totalAmount) - paid
            }
        })

        res.json({ invoices: invoicesWithBalance })
    } catch (error) {
        console.error('Error fetching invoices:', error)
        res.status(500).json({ error: 'Error fetching invoices' })
    }
})

// GET next CC (Cuenta de Cobro) number for auto-generation
// NOTE: This route MUST be before /:id to avoid being caught by the dynamic route
router.get('/next-cc-number', async (req, res) => {
    try {
        const { unitId } = req.query
        if (!unitId) {
            return res.status(400).json({ error: 'unitId is required' })
        }

        const now = new Date()
        const year = now.getFullYear()
        const month = String(now.getMonth() + 1).padStart(2, '0')
        const prefix = `CC-${year}-${month}-`

        // Find the highest CC number for this unit in current month
        const lastCC = await prisma.invoice.findFirst({
            where: {
                unitId: String(unitId),
                invoiceNumber: { startsWith: prefix },
                isAutogenerated: true
            },
            orderBy: { invoiceNumber: 'desc' }
        })

        let nextNumber = 1
        if (lastCC) {
            // Extract the number from the last CC (e.g., "CC-2024-12-005" -> 5)
            const lastNum = parseInt(lastCC.invoiceNumber.split('-').pop() || '0', 10)
            nextNumber = lastNum + 1
        }

        const nextCCNumber = `${prefix}${String(nextNumber).padStart(3, '0')}`
        res.json({ number: nextCCNumber, prefix, nextNumber })
    } catch (error) {
        console.error('Error generating CC number:', error)
        res.status(500).json({ error: 'Error generating CC number' })
    }
})

// GET invoice summary stats
router.get('/stats/summary', async (req, res) => {
    try {
        const { unitId } = req.query

        const where: any = unitId ? { unitId: String(unitId) } : {}

        const [pending, partiallyPaid, paid, drafts] = await Promise.all([
            prisma.invoice.aggregate({
                where: { ...where, status: 'PENDING' },
                _sum: { totalAmount: true },
                _count: true
            }),
            prisma.invoice.aggregate({
                where: { ...where, status: 'PARTIALLY_PAID' },
                _sum: { totalAmount: true },
                _count: true
            }),
            prisma.invoice.aggregate({
                where: { ...where, status: 'PAID' },
                _sum: { totalAmount: true },
                _count: true
            }),
            prisma.invoice.aggregate({
                where: { ...where, status: 'DRAFT' },
                _sum: { totalAmount: true },
                _count: true
            })
        ])

        res.json({
            pending: {
                count: pending._count + drafts._count,
                total: Number(pending._sum.totalAmount || 0) + Number(drafts._sum.totalAmount || 0)
            },
            partiallyPaid: {
                count: partiallyPaid._count,
                total: Number(partiallyPaid._sum.totalAmount || 0)
            },
            paid: {
                count: paid._count,
                total: Number(paid._sum.totalAmount || 0)
            },
            drafts: {
                count: drafts._count,
                total: Number(drafts._sum.totalAmount || 0)
            }
        })
    } catch (error) {
        console.error('Error fetching invoice stats:', error)
        res.status(500).json({ error: 'Error fetching stats' })
    }
})

// POST create invoice
router.post('/', async (req, res) => {
    try {
        const validation = createInvoiceSchema.safeParse(req.body)

        if (!validation.success) {
            return res.status(400).json({
                error: 'Validation Error',
                details: validation.error.format()
            })
        }

        const {
            unitId, providerId, invoiceNumber, invoiceDate, dueDate,
            subtotal, taxIva, description, pdfUrl, fileUrl, isAutogenerated
        } = validation.data

        // Check for duplicate invoice number for this provider
        const existingInvoice = await prisma.invoice.findFirst({
            where: {
                providerId,
                invoiceNumber
            }
        })

        if (existingInvoice) {
            return res.status(409).json({
                error: 'DUPLICATE_INVOICE',
                message: `Ya existe una factura con el número "${invoiceNumber}" para este proveedor.`
            })
        }

        const totalAmount = Number(subtotal) + Number(taxIva || 0)

        const invoice = await prisma.invoice.create({
            data: {
                unitId,
                providerId,
                invoiceNumber,
                isAutogenerated: isAutogenerated || false,
                invoiceDate: new Date(invoiceDate),
                dueDate: dueDate ? new Date(dueDate) : null,
                subtotal,
                taxIva: taxIva || 0,
                totalAmount,
                description,
                pdfUrl,
                fileUrl,
                status: 'PENDING'
            },
            include: {
                provider: { select: { name: true } }
            }
        })
        res.status(201).json(invoice)
    } catch (error: any) {
        console.error('Error creating invoice:', error)

        // Handle Prisma unique constraint violation
        if (error.code === 'P2002') {
            console.log('Duplicate invoice detected via Prisma P2002');
            return res.status(409).json({
                error: 'DUPLICATE_INVOICE',
                message: 'Ya existe una factura con este número para el proveedor seleccionado.'
            })
        }

        res.status(500).json({ error: 'Error creating invoice', details: error.message })
    }
})

// PUT update invoice
router.put('/:id', async (req, res) => {
    try {
        const {
            invoiceNumber, invoiceDate, dueDate,
            subtotal, taxIva, description, pdfUrl, fileUrl, status
        } = req.body

        const updateData: any = {}
        if (invoiceNumber) updateData.invoiceNumber = invoiceNumber
        if (invoiceDate) updateData.invoiceDate = new Date(invoiceDate)
        if (dueDate !== undefined) updateData.dueDate = dueDate ? new Date(dueDate) : null
        if (subtotal !== undefined) {
            updateData.subtotal = subtotal
            updateData.totalAmount = Number(subtotal) + Number(taxIva || 0)
        }
        if (taxIva !== undefined) updateData.taxIva = taxIva
        if (description !== undefined) updateData.description = description
        if (pdfUrl !== undefined) updateData.pdfUrl = pdfUrl
        if (fileUrl !== undefined) updateData.fileUrl = fileUrl
        if (status) updateData.status = status

        const invoice = await prisma.invoice.update({
            where: { id: req.params.id },
            data: updateData
        })
        res.json(invoice)
    } catch (error) {
        console.error('Error updating invoice:', error)
        res.status(500).json({ error: 'Error updating invoice' })
    }
})

// DELETE invoice
router.delete('/:id', async (req, res) => {
    try {
        // Check if invoice has payments
        const invoice = await prisma.invoice.findUnique({
            where: { id: req.params.id },
            include: { paymentItems: true }
        })

        if (invoice?.paymentItems.length) {
            return res.status(400).json({
                error: 'No se puede eliminar una factura con pagos asociados'
            })
        }

        await prisma.invoice.delete({
            where: { id: req.params.id }
        })
        res.json({ success: true })
    } catch (error) {
        console.error('Error deleting invoice:', error)
        res.status(500).json({ error: 'Error deleting invoice' })
    }
})

// GET single invoice
router.get('/:id', async (req, res) => {
    try {
        const invoice = await prisma.invoice.findUnique({
            where: { id: req.params.id },
            include: {
                provider: true,
                unit: true,
                paymentItems: {
                    include: {
                        payment: true
                    }
                }
            }
        })
        if (!invoice) {
            return res.status(404).json({ error: 'Invoice not found' })
        }

        const paid = invoice.paymentItems.reduce((sum, pi) => sum + Number(pi.amountApplied), 0)
        res.json({
            ...invoice,
            paidAmount: paid,
            balance: Number(invoice.totalAmount) - paid
        })
    } catch (error) {
        console.error('Error fetching invoice:', error)
        res.status(500).json({ error: 'Error fetching invoice' })
    }
})

export default router
