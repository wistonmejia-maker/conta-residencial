import { Router } from 'express'
import prisma from '../lib/prisma'
import { Decimal } from '@prisma/client/runtime/library'
import { createInvoiceSchema } from '../schemas/invoice.schema'

const router = Router()

// GET all invoices (optionally filtered)
router.get('/', async (req, res) => {
    try {
        const { unitId, providerId, status } = req.query

        const where: any = {}
        if (unitId) where.unitId = unitId
        if (providerId) where.providerId = providerId
        if (status) where.status = status

        const invoices = await prisma.invoice.findMany({
            where,
            include: {
                provider: { select: { name: true, nit: true } },
                paymentItems: {
                    select: { amountApplied: true }
                },
                creditNotes: {
                    select: { totalAmount: true }
                }
            },
            orderBy: { invoiceDate: 'desc' }
        })

        // Calculate paid amount and balance for each invoice
        const invoicesWithBalance = invoices.map(inv => {
            const paymentsPaid = inv.paymentItems.reduce((sum, pi) => sum + Number(pi.amountApplied), 0)
            const creditNotesTotal = (inv as any).creditNotes?.reduce((sum: number, cn: any) => sum + Number(cn.totalAmount), 0) || 0

            // Total "paid" is sum of actual payments + sum of credit notes applied to this invoice
            const totalPaid = paymentsPaid + creditNotesTotal

            return {
                ...inv,
                paidAmount: totalPaid,
                balance: Number(inv.totalAmount) - totalPaid
            }
        })

        res.json({ invoices: invoicesWithBalance })
    } catch (error) {
        console.error('Error fetching invoices:', error)
        res.status(500).json({ error: 'Error fetching invoices' })
    }
})

// GET next CC (Cuenta de Cobro) number for auto-generation
// NOTE: This route MUST be before /:id to avoid being caught by the dynamic route
router.get('/next-cc-number', async (req, res) => {
    try {
        const { unitId } = req.query
        if (!unitId) {
            return res.status(400).json({ error: 'unitId is required' })
        }

        const now = new Date()
        const year = now.getFullYear()
        const month = String(now.getMonth() + 1).padStart(2, '0')
        const prefix = `CC-${year}-${month}-`

        // Find the highest CC number for this unit in current month
        const lastCC = await prisma.invoice.findFirst({
            where: {
                unitId: String(unitId),
                invoiceNumber: { startsWith: prefix },
                isAutogenerated: true
            },
            orderBy: { invoiceNumber: 'desc' }
        })

        let nextNumber = 1
        if (lastCC) {
            // Extract the number from the last CC (e.g., "CC-2024-12-005" -> 5)
            const lastNum = parseInt(lastCC.invoiceNumber.split('-').pop() || '0', 10)
            nextNumber = lastNum + 1
        }

        const nextCCNumber = `${prefix}${String(nextNumber).padStart(3, '0')}`
        res.json({ number: nextCCNumber, prefix, nextNumber })
    } catch (error) {
        console.error('Error generating CC number:', error)
        res.status(500).json({ error: 'Error generating CC number' })
    }
})

// GET invoice summary stats
router.get('/stats/summary', async (req, res) => {
    try {
        const { unitId } = req.query

        const where: any = unitId ? { unitId: String(unitId) } : {}
        const whereNoNC = { ...where, documentType: { not: 'NOTA_CREDITO' } }

        const [pending, partiallyPaid, paid, drafts] = await Promise.all([
            prisma.invoice.aggregate({
                where: { ...whereNoNC, status: 'PENDING' },
                _sum: { totalAmount: true },
                _count: true
            }),
            prisma.invoice.aggregate({
                where: { ...whereNoNC, status: 'PARTIALLY_PAID' },
                _sum: { totalAmount: true },
                _count: true
            }),
            prisma.invoice.aggregate({
                where: { ...whereNoNC, status: 'PAID' },
                _sum: { totalAmount: true },
                _count: true
            }),
            prisma.invoice.aggregate({
                where: { ...whereNoNC, status: 'DRAFT' },
                _sum: { totalAmount: true },
                _count: true
            })
        ])

        res.json({
            pending: {
                count: pending._count + drafts._count,
                total: Number(pending._sum.totalAmount || 0) + Number(drafts._sum.totalAmount || 0)
            },
            partiallyPaid: {
                count: partiallyPaid._count,
                total: Number(partiallyPaid._sum.totalAmount || 0)
            },
            paid: {
                count: paid._count,
                total: Number(paid._sum.totalAmount || 0)
            },
            drafts: {
                count: drafts._count,
                total: Number(drafts._sum.totalAmount || 0)
            }
        })
    } catch (error) {
        console.error('Error fetching invoice stats:', error)
        res.status(500).json({ error: 'Error fetching stats' })
    }
})

// POST create invoice
router.post('/', async (req, res) => {
    try {
        const validation = createInvoiceSchema.safeParse(req.body)

        if (!validation.success) {
            return res.status(400).json({
                error: 'Validation Error',
                details: validation.error.format()
            })
        }

        const {
            unitId, providerId, invoiceNumber, invoiceDate, dueDate,
            subtotal, taxIva, retefuenteAmount, reteicaAmount,
            description, pdfUrl, fileUrl, isAutogenerated,
            documentType, relatedInvoiceId, adjustmentReason
        } = validation.data

        // Check for duplicate invoice number for this provider
        const existingInvoice = await prisma.invoice.findFirst({
            where: {
                providerId,
                invoiceNumber
            }
        })

        if (existingInvoice) {
            return res.status(409).json({
                error: 'DUPLICATE_INVOICE',
                message: `Ya existe una factura con el número "${invoiceNumber}" para este proveedor.`
            })
        }

        // Validate credit note requirements
        if (documentType === 'NOTA_CREDITO') {
            if (!relatedInvoiceId) {
                return res.status(400).json({
                    error: 'MISSING_RELATED_INVOICE',
                    message: 'Las notas crédito requieren una factura relacionada.'
                })
            }
            if (!adjustmentReason) {
                return res.status(400).json({
                    error: 'MISSING_ADJUSTMENT_REASON',
                    message: 'Las notas crédito requieren un motivo de ajuste.'
                })
            }

            // Verify related invoice exists
            const relatedInvoice = await prisma.invoice.findUnique({
                where: { id: relatedInvoiceId }
            })
            if (!relatedInvoice) {
                return res.status(404).json({
                    error: 'RELATED_INVOICE_NOT_FOUND',
                    message: 'La factura relacionada no existe.'
                })
            }
        }

        const totalAmount = Number(subtotal) + Number(taxIva || 0)

        // Create the invoice/credit note using transaction
        const invoice = await prisma.$transaction(async (tx) => {
            const newInvoice = await tx.invoice.create({
                data: {
                    unitId,
                    providerId,
                    invoiceNumber,
                    isAutogenerated: isAutogenerated || false,
                    invoiceDate: new Date(invoiceDate),
                    dueDate: dueDate ? new Date(dueDate) : null,
                    subtotal,
                    taxIva: taxIva || 0,
                    retefuenteAmount: retefuenteAmount || 0,
                    reteicaAmount: reteicaAmount || 0,
                    totalAmount,
                    description,
                    pdfUrl,
                    fileUrl,
                    status: documentType === 'NOTA_CREDITO' ? 'PAID' : 'PENDING',
                    documentType: documentType || 'FACTURA',
                    relatedInvoiceId: relatedInvoiceId || null,
                    adjustmentReason: adjustmentReason || null
                },
                include: {
                    provider: { select: { name: true } }
                }
            })

            // If it's a credit note, update original invoice status
            if (documentType === 'NOTA_CREDITO' && relatedInvoiceId) {
                const originalInvoice = await tx.invoice.findUnique({
                    where: { id: relatedInvoiceId },
                    include: {
                        paymentItems: true,
                        creditNotes: true
                    }
                })

                if (originalInvoice) {
                    const paymentsPaid = originalInvoice.paymentItems.reduce((sum, pi) => sum + Number(pi.amountApplied), 0)
                    const cnsPaid = originalInvoice.creditNotes.reduce((sum, cn) => sum + Number(cn.totalAmount), 0)
                    const totalPaid = paymentsPaid + cnsPaid

                    let newStatus = originalInvoice.status
                    if (totalPaid >= Number(originalInvoice.totalAmount)) {
                        newStatus = 'PAID'
                    } else if (totalPaid > 0) {
                        newStatus = 'PARTIALLY_PAID'
                    }

                    if (newStatus !== originalInvoice.status) {
                        await tx.invoice.update({
                            where: { id: relatedInvoiceId },
                            data: { status: newStatus }
                        })
                    }
                }
            }

            return newInvoice
        })

        res.status(201).json(invoice)
    } catch (error: any) {
        console.error('Error creating invoice:', error)

        // Handle Prisma unique constraint violation
        if (error.code === 'P2002') {
            console.log('Duplicate invoice detected via Prisma P2002');
            return res.status(409).json({
                error: 'DUPLICATE_INVOICE',
                message: 'Ya existe una factura con este número para el proveedor seleccionado.'
            })
        }

        res.status(500).json({ error: 'Error creating invoice', details: error.message })
    }
})

// PUT update invoice
router.put('/:id', async (req, res) => {
    try {
        const {
            invoiceNumber, invoiceDate, dueDate,
            subtotal, taxIva, retefuenteAmount, reteicaAmount,
            description, pdfUrl, fileUrl, status
        } = req.body

        const updateData: any = {}
        if (invoiceNumber) updateData.invoiceNumber = invoiceNumber
        if (invoiceDate) updateData.invoiceDate = new Date(invoiceDate)
        if (dueDate !== undefined) updateData.dueDate = dueDate ? new Date(dueDate) : null
        if (subtotal !== undefined) {
            updateData.subtotal = subtotal
            updateData.totalAmount = Number(subtotal) + Number(taxIva || 0)
        }
        if (taxIva !== undefined) updateData.taxIva = taxIva
        if (retefuenteAmount !== undefined) updateData.retefuenteAmount = retefuenteAmount
        if (reteicaAmount !== undefined) updateData.reteicaAmount = reteicaAmount
        if (description !== undefined) updateData.description = description
        if (pdfUrl !== undefined) updateData.pdfUrl = pdfUrl
        if (fileUrl !== undefined) updateData.fileUrl = fileUrl
        if (status) updateData.status = status

        const invoice = await prisma.$transaction(async (tx) => {
            const updatedInvoice = await tx.invoice.update({
                where: { id: req.params.id },
                data: updateData
            })

            // If it's a credit note and amount changed, update original invoice status
            if (updatedInvoice.documentType === 'NOTA_CREDITO' && updatedInvoice.relatedInvoiceId && (subtotal !== undefined || taxIva !== undefined)) {
                const originalInvoice = await tx.invoice.findUnique({
                    where: { id: updatedInvoice.relatedInvoiceId },
                    include: {
                        paymentItems: true,
                        creditNotes: true
                    }
                })

                if (originalInvoice) {
                    const paymentsPaid = originalInvoice.paymentItems.reduce((sum, pi) => sum + Number(pi.amountApplied), 0)
                    const cnsPaid = originalInvoice.creditNotes.reduce((sum, cn) => sum + Number(cn.totalAmount), 0)
                    const totalPaid = paymentsPaid + cnsPaid

                    let newStatus = 'PENDING'
                    if (totalPaid >= Number(originalInvoice.totalAmount)) {
                        newStatus = 'PAID'
                    } else if (totalPaid > 0) {
                        newStatus = 'PARTIALLY_PAID'
                    }

                    if (newStatus !== originalInvoice.status) {
                        await tx.invoice.update({
                            where: { id: updatedInvoice.relatedInvoiceId },
                            data: { status: newStatus }
                        })
                    }
                }
            }

            return updatedInvoice
        })

        res.json(invoice)
    } catch (error) {
        console.error('Error updating invoice:', error)
        res.status(500).json({ error: 'Error updating invoice' })
    }
})

// DELETE invoice
router.delete('/:id', async (req, res) => {
    try {
        // Check if invoice has payments or associated credit notes
        const invoice = await prisma.invoice.findUnique({
            where: { id: req.params.id },
            include: {
                paymentItems: true,
                creditNotes: true
            }
        })

        if (!invoice) {
            return res.status(404).json({ error: 'Factura no encontrada' })
        }

        if (invoice.paymentItems.length > 0) {
            return res.status(400).json({
                error: 'No se puede eliminar una factura con pagos asociados'
            })
        }

        if (invoice.creditNotes.length > 0) {
            return res.status(400).json({
                error: 'No se puede eliminar una factura con notas crédito asociadas. Elimine primero las notas crédito.'
            })
        }

        const relatedInvoiceId = (invoice as any).relatedInvoiceId
        const isNC = (invoice as any).documentType === 'NOTA_CREDITO'

        await prisma.$transaction(async (tx) => {
            // Delete the invoice/NC
            await tx.invoice.delete({
                where: { id: req.params.id }
            })

            // If it was a credit note, recalculate original invoice status
            if (isNC && relatedInvoiceId) {
                const originalInvoice = await tx.invoice.findUnique({
                    where: { id: relatedInvoiceId },
                    include: {
                        paymentItems: true,
                        creditNotes: true
                    }
                })

                if (originalInvoice) {
                    const paymentsPaid = originalInvoice.paymentItems.reduce((sum, pi) => sum + Number(pi.amountApplied), 0)
                    const cnsPaid = originalInvoice.creditNotes.reduce((sum, cn) => sum + Number(cn.totalAmount), 0)
                    const totalPaid = paymentsPaid + cnsPaid

                    let newStatus = 'PENDING'
                    if (totalPaid >= Number(originalInvoice.totalAmount)) {
                        newStatus = 'PAID'
                    } else if (totalPaid > 0) {
                        newStatus = 'PARTIALLY_PAID'
                    }

                    await tx.invoice.update({
                        where: { id: relatedInvoiceId },
                        data: { status: newStatus }
                    })
                }
            }
        })

        res.json({ success: true })
    } catch (error) {
        console.error('Error deleting invoice:', error)
        res.status(500).json({ error: 'Error deleting invoice' })
    }
})

// GET single invoice
router.get('/:id', async (req, res) => {
    try {
        const invoice = await prisma.invoice.findUnique({
            where: { id: req.params.id },
            include: {
                provider: true,
                unit: true,
                paymentItems: {
                    include: {
                        payment: true
                    }
                },
                creditNotes: true // Include associated credit notes
            }
        })
        if (!invoice) {
            return res.status(404).json({ error: 'Invoice not found' })
        }

        const paymentsPaid = invoice.paymentItems.reduce((sum, pi) => sum + Number(pi.amountApplied), 0)
        const creditNotesTotal = (invoice as any).creditNotes?.reduce((sum: number, cn: any) => sum + Number(cn.totalAmount), 0) || 0
        const totalPaid = paymentsPaid + creditNotesTotal

        res.json({
            ...invoice,
            paidAmount: totalPaid,
            balance: Number(invoice.totalAmount) - totalPaid
        })
    } catch (error) {
        console.error('Error fetching invoice:', error)
        res.status(500).json({ error: 'Error fetching invoice' })
    }
})

export default router
